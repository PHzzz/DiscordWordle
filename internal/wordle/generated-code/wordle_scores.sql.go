// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: wordle_scores.sql

package wordle

import (
	"context"
	"encoding/json"
	"time"
)

const countScoresByDiscordId = `-- name: CountScoresByDiscordId :one
SELECT count(*)
FROM wordle_scores
where discord_id = $1
`

func (q *Queries) CountScoresByDiscordId(ctx context.Context, discordID string) (int64, error) {
	row := q.queryRow(ctx, q.countScoresByDiscordIdStmt, countScoresByDiscordId, discordID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createScore = `-- name: CreateScore :one
INSERT INTO wordle_scores (discord_id, game_id, guesses)
VALUES ($1, $2, $3)
RETURNING id, discord_id, game_id, game_type, guesses, created_at
`

type CreateScoreParams struct {
	DiscordID string    `json:"discord_id"`
	GameID    time.Time `json:"game_id"`
	Guesses   int32     `json:"guesses"`
}

func (q *Queries) CreateScore(ctx context.Context, arg CreateScoreParams) (WordleScore, error) {
	row := q.queryRow(ctx, q.createScoreStmt, createScore, arg.DiscordID, arg.GameID, arg.Guesses)
	var i WordleScore
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.GameID,
		&i.GameType,
		&i.Guesses,
		&i.CreatedAt,
	)
	return i, err
}

const deleteScoresForUser = `-- name: DeleteScoresForUser :exec
DELETE
FROM wordle_scores
WHERE discord_id = $1
`

func (q *Queries) DeleteScoresForUser(ctx context.Context, discordID string) error {
	_, err := q.exec(ctx, q.deleteScoresForUserStmt, deleteScoresForUser, discordID)
	return err
}

const getExpectedPreviousWeekGames = `-- name: GetExpectedPreviousWeekGames :many
with max_game_week as (select max((game_id - cast('1970-01-05' as date)) / 7) -1 game_week
                       from wordle_scores
                                inner join nicknames n2 on wordle_scores.discord_id = n2.discord_id
                       where n2.server_id = $1
),
     current_week_games as (select distinct game_id
                            from wordle_scores
                                     inner join nicknames n2 on wordle_scores.discord_id = n2.discord_id
                                     inner join max_game_week on game_week = (game_id - cast('1970-01-05' as date)) / 7
                            where n2.server_id = $1)
select game_id from current_week_games
`

func (q *Queries) GetExpectedPreviousWeekGames(ctx context.Context, serverID string) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getExpectedPreviousWeekGamesStmt, getExpectedPreviousWeekGames, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var game_id time.Time
		if err := rows.Scan(&game_id); err != nil {
			return nil, err
		}
		items = append(items, game_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpectedWeekGames = `-- name: GetExpectedWeekGames :many
with max_game_week as (select max((game_id - cast('1970-01-05' as date)) / 7) game_week
                       from wordle_scores
                                inner join nicknames n2 on wordle_scores.discord_id = n2.discord_id
                       where n2.server_id = $1
),
     current_week_games as (select distinct game_id
                            from wordle_scores
                                     inner join nicknames n2 on wordle_scores.discord_id = n2.discord_id
                                     inner join max_game_week on game_week = (game_id - cast('1970-01-05' as date)) / 7
                            where n2.server_id = $1)
select game_id from current_week_games
`

func (q *Queries) GetExpectedWeekGames(ctx context.Context, serverID string) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getExpectedWeekGamesStmt, getExpectedWeekGames, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var game_id time.Time
		if err := rows.Scan(&game_id); err != nil {
			return nil, err
		}
		items = append(items, game_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoreHistoryByAccount = `-- name: GetScoreHistoryByAccount :many
SELECT id, wordle_scores.discord_id, game_id, game_type, guesses, created_at, nick.discord_id, server_id, nickname
FROM wordle_scores
         inner join nicknames nick on wordle_scores.discord_id = nick.discord_id
WHERE nick.discord_id = $1
  and nick.server_id = $2
order by game_id
`

type GetScoreHistoryByAccountParams struct {
	DiscordID string `json:"discord_id"`
	ServerID  string `json:"server_id"`
}

type GetScoreHistoryByAccountRow struct {
	ID          int64     `json:"id"`
	DiscordID   string    `json:"discord_id"`
	GameID      time.Time `json:"game_id"`
	GameType    int32     `json:"game_type"`
	Guesses     int32     `json:"guesses"`
	CreatedAt   time.Time `json:"created_at"`
	DiscordID_2 string    `json:"discord_id_2"`
	ServerID    string    `json:"server_id"`
	Nickname    string    `json:"nickname"`
}

func (q *Queries) GetScoreHistoryByAccount(ctx context.Context, arg GetScoreHistoryByAccountParams) ([]GetScoreHistoryByAccountRow, error) {
	rows, err := q.query(ctx, q.getScoreHistoryByAccountStmt, getScoreHistoryByAccount, arg.DiscordID, arg.ServerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoreHistoryByAccountRow
	for rows.Next() {
		var i GetScoreHistoryByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.DiscordID,
			&i.GameID,
			&i.GameType,
			&i.Guesses,
			&i.CreatedAt,
			&i.DiscordID_2,
			&i.ServerID,
			&i.Nickname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoresByServerId = `-- name: GetScoresByServerId :many
with max_game_week as (select max((game_id - cast('1970-01-05' as date)) / 7) game_week
                       from wordle_scores
                                inner join nicknames n2 on wordle_scores.discord_id = n2.discord_id
                       where n2.server_id = $1
)
select dense_rank() over (partition by n.server_id order by sum((7 - s.guesses) ^ 2) desc) as position,
       n.nickname,
       n.discord_id,
       json_agg(guesses order by s.game_id)             guesses_per_game,
       json_agg(json_build_object(game_id, guesses) order by s.game_id) game_guesses,
       json_agg((7 - s.guesses) ^ 2 order by s.game_id) points_per_game,
       count(distinct game_id)                          games_count,
       sum((7 - s.guesses) ^ 2)                         total
from wordle_scores s
         inner join nicknames n on s.discord_id = n.discord_id
         inner join max_game_week g on g.game_week = ((s.game_id - cast('1970-01-05' as date)) / 7)
where n.server_id = $1
group by n.server_id, n.nickname, n.discord_id
order by sum((7 - s.guesses) ^ 2) desc, count(distinct game_id) desc, nickname
`

type GetScoresByServerIdRow struct {
	Position       int64           `json:"position"`
	Nickname       string          `json:"nickname"`
	DiscordID      string          `json:"discord_id"`
	GuessesPerGame json.RawMessage `json:"guesses_per_game"`
	GameGuesses    json.RawMessage `json:"game_guesses"`
	PointsPerGame  json.RawMessage `json:"points_per_game"`
	GamesCount     int64           `json:"games_count"`
	Total          int64           `json:"total"`
}

func (q *Queries) GetScoresByServerId(ctx context.Context, serverID string) ([]GetScoresByServerIdRow, error) {
	rows, err := q.query(ctx, q.getScoresByServerIdStmt, getScoresByServerId, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoresByServerIdRow
	for rows.Next() {
		var i GetScoresByServerIdRow
		if err := rows.Scan(
			&i.Position,
			&i.Nickname,
			&i.DiscordID,
			&i.GuessesPerGame,
			&i.GameGuesses,
			&i.PointsPerGame,
			&i.GamesCount,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoresByServerIdPreviousWeek = `-- name: GetScoresByServerIdPreviousWeek :many
with max_game_week as (select (max((game_id - cast('1970-01-05' as date)) / 7)) - 1 game_week
                       from wordle_scores
                                inner join nicknames n2 on wordle_scores.discord_id = n2.discord_id
                       where n2.server_id = $1
)
select dense_rank() over (partition by n.server_id order by sum((7 - s.guesses) ^ 2) desc) as position,
       n.nickname,
       n.discord_id,
       json_agg(guesses order by s.game_id)             guesses_per_game,
       json_agg(json_build_object(game_id, guesses) order by s.game_id) game_guesses,
       json_agg((7 - s.guesses) ^ 2 order by s.game_id) points_per_game,
       count(distinct game_id)                          games_count,
       sum((7 - s.guesses) ^ 2)                         total
from wordle_scores s
         inner join nicknames n on s.discord_id = n.discord_id
         inner join max_game_week g on g.game_week = ((game_id - cast('1970-01-05' as date)) / 7)
where n.server_id = $1
group by n.server_id, n.nickname, n.discord_id
order by sum((7 - s.guesses) ^ 2) desc, count(distinct game_id) desc, nickname
`

type GetScoresByServerIdPreviousWeekRow struct {
	Position       int64           `json:"position"`
	Nickname       string          `json:"nickname"`
	DiscordID      string          `json:"discord_id"`
	GuessesPerGame json.RawMessage `json:"guesses_per_game"`
	GameGuesses    json.RawMessage `json:"game_guesses"`
	PointsPerGame  json.RawMessage `json:"points_per_game"`
	GamesCount     int64           `json:"games_count"`
	Total          int64           `json:"total"`
}

func (q *Queries) GetScoresByServerIdPreviousWeek(ctx context.Context, serverID string) ([]GetScoresByServerIdPreviousWeekRow, error) {
	rows, err := q.query(ctx, q.getScoresByServerIdPreviousWeekStmt, getScoresByServerIdPreviousWeek, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoresByServerIdPreviousWeekRow
	for rows.Next() {
		var i GetScoresByServerIdPreviousWeekRow
		if err := rows.Scan(
			&i.Position,
			&i.Nickname,
			&i.DiscordID,
			&i.GuessesPerGame,
			&i.GameGuesses,
			&i.PointsPerGame,
			&i.GamesCount,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScores = `-- name: ListScores :many
SELECT id, discord_id, game_id, game_type, guesses, created_at
FROM wordle_scores
ORDER BY created_at
`

func (q *Queries) ListScores(ctx context.Context) ([]WordleScore, error) {
	rows, err := q.query(ctx, q.listScoresStmt, listScores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WordleScore
	for rows.Next() {
		var i WordleScore
		if err := rows.Scan(
			&i.ID,
			&i.DiscordID,
			&i.GameID,
			&i.GameType,
			&i.Guesses,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScore = `-- name: UpdateScore :one
update wordle_scores
set guesses = $2
where discord_id = $1
  and game_id = $3
returning id, discord_id, game_id, game_type, guesses, created_at
`

type UpdateScoreParams struct {
	DiscordID string    `json:"discord_id"`
	Guesses   int32     `json:"guesses"`
	GameID    time.Time `json:"game_id"`
}

func (q *Queries) UpdateScore(ctx context.Context, arg UpdateScoreParams) (WordleScore, error) {
	row := q.queryRow(ctx, q.updateScoreStmt, updateScore, arg.DiscordID, arg.Guesses, arg.GameID)
	var i WordleScore
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.GameID,
		&i.GameType,
		&i.Guesses,
		&i.CreatedAt,
	)
	return i, err
}
